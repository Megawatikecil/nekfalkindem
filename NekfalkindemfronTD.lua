if gg.isPackageInstalled("sstool.only.com.sstool") then
    i = 1
    gg.alert("üò°üò°WARNINGüò°üò°\n\n APPLICATIONS THAT HARMFUL SCRIPTS ARE DETECTED\n\n FOR SECURITY THE SCRIPT WAS AUTOMATICALLY DELETED")
   trash = gg.getFile():match('[^/]+$')
os.remove(trash)
    gg.setVisible(false)
    while true do
      gg.setVisible(false)      
      gg.setVisible(true)
    end
    return
  end
  
  if gg.isPackageInstalled("com.guoshi.httpcanary") then
    i = 1
    gg.alert("üò°üò°WARNINGüò°üò°\n\n APPLICATIONS THAT HARMFUL SCRIPTS ARE DETECTED\n\n FOR SECURITY THE SCRIPT WAS AUTOMATICALLY DELETED")
   trash = gg.getFile():match('[^/]+$')
os.remove(trash)
    gg.setVisible(false)
    while true do
      gg.setVisible(false)      
      gg.setVisible(true)
    end
    return
  end

if gg.isPackageInstalled("com.fnmods.sstool") then
    i = 1
    gg.alert("üò°üò°WARNINGüò°üò°\n\n APPLICATIONS THAT HARMFUL SCRIPTS ARE DETECTED\n\n FOR SECURITY THE SCRIPT WAS AUTOMATICALLY DELETED")
   trash = gg.getFile():match('[^/]+$')
os.remove(trash)
    gg.setVisible(false)
    while true do
      gg.setVisible(false)      
      gg.setVisible(true)
    end
    return
  end

if gg.isPackageInstalled("com.guoshi.httpcanary.premium") then
    i = 1
    gg.alert("üò°üò°WARNINGüò°üò°\n\n APPLICATIONS THAT HARMFUL SCRIPTS ARE DETECTED\n\n FOR SECURITY THE SCRIPT WAS AUTOMATICALLY DELETED")
   trash = gg.getFile():match('[^/]+$')
os.remove(trash)
    gg.setVisible(false)
    while true do
      gg.setVisible(false)      
      gg.setVisible(true)
    end
    return
  end
  
if gg.isPackageInstalled("com.emanuelef.remote_capture") then
    i = 1
    gg.alert("üò°üò°WARNINGüò°üò°\n\n APPLICATIONS THAT HARMFUL SCRIPTS ARE DETECTED\n\n FOR SECURITY THE SCRIPT WAS AUTOMATICALLY DELETED")
   trash = gg.getFile():match('[^/]+$')
os.remove(trash)
    gg.setVisible(false)
    while true do
      gg.setVisible(false)      
      gg.setVisible(true)
    end
    return
  end
  

  
  



--===================================



LUA = 'NIGHTFALL KINGDOM FRONTIER TD[Auto Update].lua'
GLabel = 'NIGHTFALL KINGDOM FRONTIER TD'
GProcess = 'com.fansipan.nightfall.tower.simulation.strategy.td.game'
GVersion = '(Auto-Update)'
xbit = 64 
LibResult = 1
xlib = 'libil2cpp.so'
xlibsize = 0
xREV = 1  I={}
xCNE = 0
xSSE = 0
XbitX = 2
printx = '---------------------------------------------------------------'
print(printx)
xTAGx = 'RISK BANNED,BE CAREFUL'
print(xTAGx)
xMOTOx = 'CHEATING IS AN ART IN THE GAME'
print(xMOTOx)
xLINKx = 'NIGHTFALL KINGDOM FRONTIER TD'
print(xLINKx)
print(LUA)
print(GLabel..'  '..GVersion)
print(printx)
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
-- APEX[GG]v2

gg.require('101.1')
A={} for i = 1,100 do A[i]={} end
apex=1
gg.setVisible(false)
v=gg.getTargetInfo()
    if v==nil then
        print("√ó√ó ERROR √ó√ó\n√ó√ó INVALID PROCESS SELECTED / OR NO ROOT ACCESS") 
        gg.setVisible(true) os.exit()
        return
    end 
    AUalert="\nThis Script Auto-Updates\nPlease Wait...\n" 
-- [START] / [NO] 
------------------------------------------------------------------------------

off="[ √ó ] " on="[ ‚àö ] " OFF ="[ ‚ùç‚äÉ ] " ON="[ ‚äÇ‚ùç ] " offf="[ ‚äÇ‚ùç‚äÉ ] "
gm=off ck=off 
sh=off  sh2=off sh3=off NA=OFF eq=offf
lv=off mr=off
gs=1 
b=1 w=2 d=4 f=16 q=32 e=64 
function menu()
gg.setRanges(gg.REGION_ANONYMOUS) 
gg.toast(xTAGx)  
mc=gg.multiChoice({
	gm.."FREE IN-APP PURCHASE",
	ck.."AUTO LAST WAVE",
	sh.."BUILDING HIGH HP",
	mr.."MERGE NO REQUIRED DUPLICATE",
	"‚Ä¢‚Ä¢‚Ä¢SILVER COIN BATTLE‚Ä¢‚Ä¢‚Ä¢",
	"‚Ä¢‚Ä¢‚Ä¢LEVEL EQUIPMENT‚Ä¢‚Ä¢‚Ä¢",
	
	    "[ INFO ]",
	
	"[ EXIT ]"},nil,  (os.date([[‚ï≠ ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ¬°! ‚Ä¢ !¬°‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ ‚ïÆ
   Akira_Kohei
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  Today : %A, %d %B %Y
  Time : %H : %M : %S
‚ï∞ ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ¬°! ‚Ä¢ !¬°‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ‚îÄ‚îâ‚îÄ ‚ïØ]])))
	
	if mc==nil then cancel() return end
	if mc[1] then godmode() end
	if mc[2] then wave() end
	if mc[3] then building() end 
	if mc[4] then merge() end 
	if mc[5] then a1() end
	if mc[6] then level() end
	if mc[7] then camera() end 

	if mc[8] then exit() return end 

gg.toast("[‚àö] Complete")  

end
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
function camera()
gg.alert[[‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£¥‚£∂‚°ã‚†â‚†ô‚†í‚¢§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä ‚¢†‚†ñ‚†â‚†â‚†ô‚†¢‚°Ñ‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ü‚°í‚†í‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚£Ü‚†Ä‚†Ä‚†Ä‚¢†‚†É :‚†Ä:._.:    ‚†π‚°Ñ
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†∑‚†ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚°Ü‚†Ä‚†Ä‚°á‚†Ä :‚†Ä: :  :‚†Ä ‚†Ä‚¢∑
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∑‚°í‚†Ä‚†Ä‚¢ê‚£í‚£í‚°í‚†Ä‚£ê‚£í‚£í‚£ß‚†Ä‚†Ä‚°á‚†Ä‚¢†‚¢§‚¢†‚°†‚†Ä‚†Ä  ‚¢∏
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£õ‚£ü‚£Ç‚†Ä‚†ò‚†§‚†¨‚†É‚†∞‚†ë‚†•‚†ä‚£ø‚†Ä‚¢¥‚†É‚†Ä‚†ò‚†ö‚†ò‚†ë‚†ê  ‚†Ä‚¢∏
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚°ø‚†§‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°Ü‚†Ä‚†Ä‚£ø‚†Ä‚†Ä‚°á‚†Ä‚†Äi`m ok‚†Ä ‚£∏
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ø‚£Ø‚°≠‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚†Ä‚†Ä‚†Ä‚°ü‚†Ä‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†è
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢Ø‚°•‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°º‚†Å‚†Ä‚†Ä‚†Ä‚†≥‚¢Ñ‚£Ä‚£Ä‚£Ä‚°¥‚†É‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢±‚°¶‚£Ñ‚£Ä‚£Ä‚£Ä‚£†‚†û‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£æ‚†õ‚†É‚†Ä‚†Ä‚†Ä‚¢π‚†≥‚°∂‚£§‚°§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚¢¥‚£ø‚£ø‚£ø‚°ü‚°∑‚¢Ñ‚£Ä‚£Ä‚£Ä‚°º‚†≥‚°π‚£ø‚£∑‚†û‚£≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚¢∞‚°Ø‚†≠‚†π‚°ü‚†ø‚†ß‚†∑‚£Ñ‚£Ä‚£ü‚†õ‚£¶‚†î‚†ã‚†õ‚†õ‚†ã‚†ô‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢∏‚£ø‚†≠‚†â‚†Ä‚¢†‚£§‚†Ä‚†Ä‚†Ä‚†ò‚°∑‚£µ‚¢ª‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†Ä‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚°á‚£ø‚†ç‚†Å‚†Ä‚¢∏‚£ó‚†Ç‚†Ä‚†Ä‚†Ä‚£ß‚£ø‚£º‚†Ä‚†Ä‚†Ä‚†Ä‚£Ø‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä]]

gg.setVisible(false)
local ozorayuu=gg.alert(" Contact the creator,For new update version\n\n Telegram:Riffavenue\n\nWhatsApp:085807155569\n\nScript only for x64bit","[NEXT]","","[COPY LINK TELEGRAM]")
  
    if ozorayuu==3 then 
        gg.copyText("https://t.me/Riffavenue",false) 
        gg.toast("Link Copied\nhttps://t.me/Riffavenue")
     end 
end



GM=0
function godmode()
    if GM==0 then
        clear() wait() x="PackData" t=4 o=0x10 class()
        x="3" refine()
        o=0 t=4 offset() x="3" refine()
        check() if E==0 then error() return end 
        x1=gg.getResults(gg.getResultsCount())
        x2=gg.getResults(gg.getResultsCount())
        clear() GM=1
    end 
 
    if gm==off then
        for i, v in ipairs(x2) do
            v.value=0
            
        end
        gg.alert("Only Item In Shop")
        gg.setValues(x2)
        gm=on
    else
        gg.setValues(x1)
        gm=off
    end
end 
    
    
    
CK=0
function wave()
    if CK==0 then
        -- cari base address
        gg.clearResults()
        gg.setRanges(32)
        gg.searchNumber(13, gg.TYPE_QWORD)
        HackersHouse = gg.getResults(250000)

        Offsets = {}
        Offsets['FirstOffset'] = {}
        Offsets['SecondOffset'] = {}
        Offsets['FinalResults'] = {}
        OffsetsIndex = 1

        for i, v in ipairs(HackersHouse) do
            Offsets['FirstOffset'][OffsetsIndex] = {
                address = v.address - 32,
                flags = gg.TYPE_QWORD
            }
            Offsets['SecondOffset'][OffsetsIndex] = {
                address = v.address - 28,
                flags = gg.TYPE_QWORD
            }
            OffsetsIndex = OffsetsIndex + 1
        end

        Offsets['FirstOffset'] = gg.getValues(Offsets['FirstOffset'])
        Offsets['SecondOffset'] = gg.getValues(Offsets['SecondOffset'])

        OffsetsIndex = 1
        for i, v in ipairs(Offsets['FirstOffset']) do
            if (Offsets['FirstOffset'][i].value == 1099511627776) 
               and (Offsets['SecondOffset'][i].value == 256) then
                Offsets['FinalResults'][OffsetsIndex] = Offsets['FirstOffset'][i]
                OffsetsIndex = OffsetsIndex + 1
            end
        end

        for i, v in ipairs(Offsets['FinalResults']) do
            v.address = v.address + 112
            v.flags = 4
        end

        gg.loadResults(Offsets['FinalResults'])
        check() if E==0 then error() return end

        local tmp = gg.getResults(gg.getResultsCount())
        
        -- simpan nilai original
        original = {}
        for i, v in ipairs(tmp) do
            original[i] = {
                address = v.address,
                flags   = v.flags,
                value   = v.value
            }
        end

        -- copy buat nilai edit
        x4 = {}
        for i, v in ipairs(tmp) do
            x4[i] = {
                address = v.address,
                flags   = v.flags,
                value   = v.value
            }
        end

        CK=1
        ck=off
    end

    if ck==off then
        for i, v in ipairs(x4) do
            v.value=15
            v.freeze=true
        end
        gg.setValues(x4)
        gg.addListItems(x4) -- freeze aktif
        gg.alert("Hack Last Wave ON\n\nNote:Turn off then turn on again if doesn't work")
        ck=on
    else
        gg.removeListItems(x4) -- hapus freeze
        gg.setValues(original) -- restore nilai asli
        gg.alert("Hack Last Wave OFF\n\nNote:Turn off then turn on again if doesn't work")
        ck=off
    end
end




function a1()
    local choice = gg.alert(
        "Hack Silver Coin.\n\nPlease activate in battle.\n\nAre you in battle?",
        "Yes",      -- button 1
        "No",       -- button 2
        "Akira_Kohei"  -- button 3
    )

    if choice == 1 then
        -- Yes, lanjut ke input value
        local xinput = gg.prompt(
            {"Input Value Silver Coin You Want:"},
            {900},     -- default value
            {"number"} -- tipe input
        )

        if xinput == nil then
            gg.toast("‚ùå Canceled")
            return
        end

        clear() 
        wait() 
        x="21474840491" t=32 search()
       -- x="21474837483" t=32 search()
       -- x="12884902889" t=32 search()
        check() if E==0 then error() return end     

        o=0x30 t=16 offset() 
        x="0~1000000" refine() t=16
        check() if E==0 then error() return end     

        x=tostring(xinput[1]) t=16 edit()

        gg.clearList()
        gg.clearResults()
        gg.toast("‚úÖ H4ck Activate, value = "..xinput[1])

    elseif choice == 2 then
        -- No
        gg.toast("‚ùå Canceled, back to menu")
        return

    elseif choice == 3 then
        -- Minimize
        gg.toast("üîΩ Minimized")
        gg.setVisible(false)
        -- tunggu sampai GG muncul lagi
        while true do
            if gg.isVisible(true) then
                gg.setVisible(false)
                -- balik ke fungsi a1
                return a1()
            end
        end
    end
end

function a11()
clear() wait() x="12884902889" t=32 search()
        check() if E==0 then error() return end     
        o=0x10 t=16 offset() 
        x="0~1000000" refine() t=16
        check() if E==0 then error() return end     
        x="900" t=16 edit()
         gg.clearList()
         gg.clearResults()
         gg.toast("H4ck Activate")
    end

function a11()
clear() wait() x="Thread" t=4 o=0x788 class()
        x="1001" refine() t=4
        check() if E==0 then error() return end     
        o=0x10 t=16 offset() 
        x="0~1000000" refine() t=16
        check() if E==0 then error() return end     
        x="1000000" t=16 edit()
    end

function a11()
clear() wait() x="Thread" t=4 o=0x848 class()
        x="500~100000" refine() t=4
        check() if E==0 then error() return end     
        o=0x10 t=16 offset() 
        x="0~1000000" refine() t=16
        check() if E==0 then error() return end     
        x="1000000" t=16 edit()
    end


original_values_a5 = original_values_a5 or {}
function level()
    clear()
    wait()
    xinput = gg.prompt(
        {
            [1] = "Akira_Kohei\nInput Value Level Equipment You Want.\nMax Value Input 2147483646.",
          --  [2] = "‚úî Restore Original Values (Uncheck = Activate Hack)"
        },
        {
            [1] = '100',
          --  [2] = false
        },
        {
            [1] = 'number',
        --    [2] = 'checkbox'
        }
    )

    if not xinput then
        gg.toast("Canceled")
        gg.sleep(1000)
        gg.toast("Please Input Value")
        return
    end

    if xinput[2] then
        if original_values_a5 and #original_values_a5 > 0 then
            gg.removeListItems(original_values_a5) 
            gg.setValues(original_values_a5)      
            gg.toast("Values Restored")
        else
            gg.toast("No values to restore")
        end
        return
    end

    gg.setRanges(gg.REGION_ANONYMOUS)
    clear()
    wait()
 
    x = "3;-1;1;-1;2;-1;4;-1::53"
    t = 4
    search()
    x = "3" t = 4 refine()
    check()
    if E == 0 then
        error()
        return
    end

    local baseResults = gg.getResults(10000000)
    original_values_a5 = {}
    local offsets = {0xC, 0x1C, 0x2C, 0x3C}
    local flatResults = {}

    for _, off in ipairs(offsets) do
        for _, v in ipairs(baseResults) do
            local addr = v.address + off
            local nv = {
                address = addr,
                flags = gg.TYPE_DWORD,
                value = tonumber(xinput[1]), -- pakai input angka
                freeze = false,
                name = "Type_" .. string.format("%X", off)
            }
            table.insert(flatResults, nv)
            table.insert(original_values_a5, {
                address = addr,
                flags = gg.TYPE_DWORD,
                value = gg.getValues({{address = addr, flags = gg.TYPE_DWORD}})[1].value
            })
        end
    end
  --  gg.addListItems(flatResults)
    gg.setValues(flatResults)
    gg.clearResults()
    gg.toast("H4ck Activate")
end
    
A[1].class="BuildingDataContainer" 
A[1].method="get_CurrentHealth" 
A[2].class="BuildingDataContainer" 
A[2].method="get_MaxHealth" 
function building()
if A[1].error==1 or A[2].error==1 then error() return end
    for i = A[1].start, A[2].finish do
    o=I[i]
   x={'528D6500h','72A9DDC0h','1E270000h','D65F03C0h'} --2b flo
        if sh==off then arm() else revert() end
    end
    if sh==off then sh=on else sh=off end
end 
 
 
A[3].class="ItemFusionService" 
A[3].method="FoodIsCopy" 
A[4].class="ItemFusionService" 
A[4].method="IsFoodForMainItem"
A[5].class="ItemFusionService" 
A[5].method="CanFusionItem"
function merge()
	gg.alert("Dont click merge all,because it will remove all equipment in the inventory")
if A[3].error==1 or A[5].error==1 then error() return end
    for i = A[3].start, A[5].finish do
    o=I[i]
  x={'h200080D2','hC0035FD6'}
		
        if mr==off then arm() else revert() end
    end
    if mr==off then mr=on else mr=off end
end        
        
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
if v.x64 then
xtrue="h200080D2" -- MOV X0, #0x1
xfalse="h000080D2" -- MOV X0, #0x0 
xEND="hC0035FD6" -- RET
else 
xtrue="h0100A0E3" -- MOVW R0, #1 
xfalse="h0000A0E3" -- MOVW R0, #0 
xEND="h1EFF2FE1" -- BX LR 
end 


function arm()
o=tonumber(o) 
    for XxX=1,#(xAPEXx) do
        xdump=nil xdump={} 
        if type(x)~="table" then 
        xdump[1]={} xdump[2]={}
        xdump[1].address=xAPEXx[XxX] + o
        xdump[1].flags=4
            if x==0 then xdump[1].value=xfalse end
            if x==1 then xdump[1].value=xtrue end
            if x~=0 and x~=1 then xdump[1].value=x end 
        xdump[2].address=xAPEXx[XxX]+(o+4)
        xdump[2].flags=4
        xdump[2].value=xEND 
        else
        cc=0
            for c=1,#(x) do
            xdump[c]={} 
            xdump[c].address=xAPEXx[XxX]+o+cc
            xdump[c].flags=4   
            xdump[c].value=tostring(x[c])
            cc=cc+4
            end         
        end 
    gg.setValues(xdump) 
    end 
end 


------------------------------------------------------------------------------  
function revert()
    for XxX=1,#(xAPEXx) do 
    REVERT=nil REVERT={} xRx=nil xRx=1 
        for i, v in ipairs(ORIG) do
            if tonumber(xAPEXx[XxX]+o)==ORIG[i].address then
                if type(x)~="table" then
                    REVERT[xRx]={}
                    REVERT[xRx].address=xAPEXx[XxX]+o
                    REVERT[xRx].flags=4
                    REVERT[xRx].value=ORIG[i].value
                    xRx=xRx+1
                    REVERT[xRx]={}
                    REVERT[xRx].address=xAPEXx[XxX]+o+4
                    REVERT[xRx].flags=4
                    REVERT[xRx].value=ORIG[i+1].value 
                    xRx=xRx+1 
                else              
                offcnt=0 tnuc=0
                    for dfg=1,#(x) do 
                    REVERT[xRx]={}
                    REVERT[xRx].address=xAPEXx[XxX]+o+offcnt 
                    REVERT[xRx].flags=4
                    REVERT[xRx].value=ORIG[i+tnuc].value
                    offcnt=offcnt+4 tnuc=tnuc+1 xRx=xRx+1
                    end 
                end 
            gg.setValues(REVERT) 
            break
            end
            -- xRx+1 
        end 
    end 
end 
-- class StageData 
-- int stamina; // 0x10



--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
if v.processName~=GProcess then
        print("This Script is For:\n    "..GLabel.."\n    "..GProcess.."\nYou Selected:\n    "..v.label.."\n    "..v.processName)
        gg.setVisible (true) os.exit()
        return
    end 
------------------------------------------------------------------------------
    if v.x64 then bitx=64 xBITx="[x64]" else bitx=32 xBITx="[x32]" end 
        print(xBITx)  
        print(printx)  
------------------------------------------------------------------------------
    if XbitX==1 then 
        if bitx~=xbit then 
            print("This Script is For "..xbit.."bit Process\nYour Process is "..bitx.."bit")
            gg.setVisible(true) os.exit()
            return
        end 
    end 
------------------------------------------------------------------------------
-- APEX[GG]v2

--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
    if LibResult==1 then 
    xAPEXx={} xXx=0
    xLibRes=0 
    libx=gg.getRangesList()
        if #(libx)==0 then 
        print("√ó√ó LIB ERROR #01 √ó√ó\nNo Libs Found\nTry a Different Virtual Environment \nor Try a Better Game Installation Method\nor Download Game From 'apkcombo.com' ")
        gg.setVisible(true) 
        os.exit() 
        end
    libx=gg.getRangesList(xlib)
        if #(libx)==0 then  
        print("√ó√ó No "..xlib.." Found")
        xLibRes=2 
        goto APEX_SPLIT 
        end
    xlibn=0 
        for i, v in ipairs(libx) do 
            if libx[i].state=="Xa" then 
            xXx=xXx+1 
            xAPEXx[xXx]=libx[i].start 
            XLIBSIZE=libx[i]["end"]-libx[i].start 
            xLibRes=1
            end
        end 
        if xLibRes==0 then 
        print("√ó√ó LIB ERROR #03 √ó√ó\nNo "..xlib.." Found in Xa\nTry a Different Virtual Environment \nor Try a Better Game Installation Method\nor Download Game From 'apkcombo.com' ")
        gg.setVisible(true) 
        os.exit()     
        end    
                  
        ::APEX_SPLIT::     
        if xLibRes==2 then
        splitapk=0
        libx=gg.getRangesList()
            for i, v in ipairs(libx) do 
                if libx[i].state=="Xa" and string.match(libx[i].name,"split_config") then
                splitapk=1
                end
            end 
            if splitapk==1 then 
            xsapk={} xsapkx=0
                for i, v in ipairs(libx) do
                    if libx[i].state=="Xa" then
                    xsapkx=xsapkx+1
                    xsapk[xsapkx]=libx[i]["end"]-libx[i].start
                    end
                end 
                if xsapkx~=0 then                 
                APEXQ=math.max(table.unpack(xsapk))
                    for i, v in ipairs(libx) do              
                        if libx[i].state=="Xa" and libx[i]["end"]-libx[i].start==APEXQ then              
                        xXx=xXx+1             
                       xAPEXx[xXx]=libx[i].start
                       XLIBSIZE=libx[i]["end"]-libx[i].start 
                        print("‚àö‚àö Split Apk Lib Found\n‚àö‚àö "..libx[i].name) 
                        xLibRes=1                       
                        end
                    end
                end 
            end 
         
             if splitapk==0 and xLibRes~=1 then
             print("√ó√ó No split_config Lib Found")  
             xc=1 xt={} 
             libx=gg.getRangesList()
                 for i, v in ipairs(libx) do
                     if libx[i].state=="Xa" then 
                     xt[xc]=tonumber(libx[i]["end"]-libx[i].start) 
                     xc=xc+1
                     end
                 end
                 if xc==1 then
                     print("√ó√ó No libs in Xa Region\n-- Your Device is Broken --\nGoodbye")
                     gg.setVisible(true)  os.exit() 
                     return
                 end 
             APEXQ=math.max(table.unpack(xt))
                 for i, v in ipairs(libx) do              
                     if libx[i].state=="Xa" and libx[i]["end"]-libx[i].start==APEXQ then        
                     xXx=xXx+1       
                     xAPEXx[xXx]=libx[i].start
                     XLIBSIZE=libx[i]["end"]-libx[i].start 
                     print("‚àö‚àö math.max Xa Lib Found\n‚àö‚àö "..libx[i].name) 
                     xLibRes=1   
                     end 
                 end
            end                        

            if xLibRes~=1 then
            print("√ó√ó Correct Lib Not Found √ó√ó\n√ó√ó Direct/Split Config/Xa Max √ó√ó")
            gg.setVisible(true) 
            os.exit()
             return
            end 
        end 
   
        if xlibsize~=0 then  
            if XLIBSIZE<xlibsize then
            print("√ó√ó Incorrect Lib Size in Xa Region √ó√ó\nYour device / virtual / emulator is not compatible with this script")
            gg.setVisible(true) 
            os.exit()
            return
            end 
        end 
        
    end 
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
function search()
gg.getResults(gg.getResultsCount())
gg.clearResults()
gg.searchNumber(x,t) 
end 

function error()
gg.toast("√ó ERROR,VALUE NOT FOUND √ó")

gg.sleep(1000)
end 

--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
function class()
gg.clearResults()
if true then
    local org = gg.searchNumber
    local hook = function(FFF)
        gg.setVisible(false)
        local ret = org(FFF)
        if gg.isVisible(true) then
     while true do 
     for i = 1, 10000 do
     gg.setVisible(false)
     gg.clearResults()
     gg.toast("ANTIVIEW SEARCHNUMBER !")
     end
     gg.toast("ANTIVIEW SEARCHNUMBER !")
     gg.clearResults()
     gg.clearList()
     return ret
    end
    end
    end
    gg.searchNumber = hook
end

gg.clearResults()
gg.setRanges(gg.REGION_OTHER | gg.REGION_ANONYMOUS | gg.REGION_C_ALLOC) 
gg.searchNumber(":"..x,1)
    if gg.getResultsCount()==0 then E=0 return end 
apexu=nil apexu=gg.getResults(1)
gg.getResults(gg.getResultsCount())
gg.refineNumber(tonumber(apexu[1].value),1)
apexu=nil apexu=gg.getResults(gg.getResultsCount())
gg.clearResults()
    for i, v in ipairs(apexu) do apexu[i].address=apexu[i].address-1 apexu[i].flags=1
    end
apexu=gg.getValues(apexu) apexa={} apexaa=1 
    for i, v in pairs(apexu) do
        if apexu[i].value==0 then
        apexa[apexaa]={} apexa[apexaa].address=apexu[i].address apexa[apexaa].flags=1 apexaa=apexaa+1
        end
    end   
if #(apexa)==0 then gg.clearResults() E=0 return end 
u=nil
    for i, v in ipairs(apexa) do apexa[i].address=apexa[i].address+#(x)+1 apexa[i].flags=1
    end  
apexa=gg.getValues(apexa) apexs=nil apexs={} apexbb=1
    for i, v in ipairs(apexa) do
        if apexa[i].value==0 then apexs[apexbb]={} apexs[apexbb].address=apexa[i].address apexs[apexbb].flags=1 apexbb=apexbb+1
        end
    end
if #(apexs)==0 then gg.clearResults() E=0 return end 
apexa=nil
    for i, v in ipairs(apexs) do apexs[i].address=apexs[i].address-#(x) apexs[i].flags=1
    end
gg.loadResults(apexs) 
gg.searchPointer(0)
if gg.getResultsCount()==0 then E=0 return end   
apexu=gg.getResults(gg.getResultsCount())
gg.clearResults() 
if gg.getTargetInfo().x64 then apexo1=48 apexo2=56 apexvt=32 else apexo1=24 apexo2=28 apexvt=4 end
ERROR=0 
::TRYAGAIN:: 
apexy=nil apexy={} apexz=nil apexz={} 
    for i, v in ipairs(apexu) do
    apexy[i]={} apexy[i].address=apexu[i].address+apexo1 apexy[i].flags=apexvt
    apexz[i]={} apexz[i].address=apexu[i].address+apexo2 apexz[i].flags=apexvt
    end 
apexy=gg.getValues(apexy) apexz=gg.getValues(apexz) apexp=nil apexp={} apexxx=1
    for i, v in ipairs(apexy) do
        if apexy[i].value==apexz[i].value and #(tostring(apexy[i].value))>=8 then
        apexp[apexxx]=apexy[i].value
        apexxx=apexxx+1
        end
    end
apexxx=nil apexy=nil apexz=nil
    if #(apexp)==0 and ERROR==0 then
        if gg.getTargetInfo().x64 then apexo1=32 apexo2=40 else apexo1=16 apexo2=20 end 
    ERROR=2 
    goto TRYAGAIN
    end    
if #(apexp)==0 and ERROR==2 then E=0 return end
gg.setRanges(gg.REGION_ANONYMOUS) 
gg.clearResults() apexxxx=1
    for i, v in ipairs(apexp) do
    gg.toast("Please Wait...") 
    gg.searchNumber(tonumber(apexp[i]),apexvt)
        if gg.getResultsCount()~=0 then
        apexxx=nil apexxx=gg.getResults(gg.getResultsCount()) gg.clearResults()
            for apexq=1,#(apexxx) do apexxx[apexq].name="APEX[GG]v2"
            end
        gg.addListItems(apexxx) apexxxx=apexxxx+1
        end
    gg.clearResults()
    end 
apexu=nil apexp=nil apexxx=nil apexq=nil 
if apexxxx==1 then gg.clearResults() E=0 return end
apexxxx=nil apexload={} apexremove={} apexxx=1
apexu=gg.getListItems()
    for i, v in ipairs(apexu) do
        if apexu[i].name=="APEX[GG]v2" then 
        apexload[apexxx]={} apexload[apexxx].address=apexu[i].address+o apexload[apexxx].flags=t
        apexremove[apexxx]={} apexremove[apexxx]=apexu[i] apexxx=apexxx+1
        end
    end 
apexload=gg.getValues(apexload) gg.loadResults(apexload) gg.removeListItems(apexremove) 
end
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
b=1 w=2 d=4 f=16 q=32 e=64 
------------------------------------------------------------------------------  
function exit()
gg.getListItems()
gg.clearList()
gg.getResults(gg.getResultsCount())
gg.clearResults()
gg.toast("[ EXIT ]")  
    if xhaX~=nil then 
        print(printx) 
        print(xhaX) 
        print(printx)  
    end 
gg.setVisible(true) 
os.exit()
return
end 
function cancel()
gg.toast("Cancelled")
end
function clear()
gg.clearList()
gg.clearResults()
end
------------------------------------------------------------------------------  
function get()
gg.getResults(gg.getResultsCount())
end 
------------------------------------------------------------------------------  
function search()
gg.getResults(gg.getResultsCount())
gg.clearResults()
gg.searchNumber(x,t) 
end 
------------------------------------------------------------------------------  
function refine()
gg.refineNumber(x,t) 
end 
------------------------------------------------------------------------------  
function refinenot()
gg.refineNumber(x,t,false,gg.SIGN_NOT_EQUAL) 
end 
------------------------------------------------------------------------------  
function edit()
gg.getResults(gg.getResultsCount())
gg.editAll(x,t) 
end 
------------------------------------------------------------------------------  
function check()
E=nil E=gg.getResultsCount()
end 
------------------------------------------------------------------------------  
function offset()
o=tonumber(o) addoff=nil 
addoff=gg.getResults(gg.getResultsCount())
    for i, v in ipairs(addoff) do
        addoff[i].address=addoff[i].address+o
        addoff[i].flags=t
    end
gg.loadResults(addoff) 
end 
------------------------------------------------------------------------------  
function head() 
gg.toast("Please Wait") 
header=nil 
header=gg.getResults(1)
gg.getResults(gg.getResultsCount())
gg.clearResults()
gg.searchNumber(tostring(header[1].value),t)
end 
-----------------------------------------
function heads()
gg.toast("Please Wait..") 
gg.getResults(gg.getResultsCount())
gg.clearResults()
gg.searchNumber(tostring(header[1].value),t) 
gg.getResults(gg.getResultsCount())
end 
-----------------------------------------
function headg()
gg.getResults(gg.getResultsCount())
header = gg.getResults(1)
end 
-----------------------------------------
function heade()
gg.editAll(tostring(header[1].value),t) 
end 

------------------------------------------------------------------------------  
function freeze()
frz=nil 
frz=gg.getResults(gg.getResultsCount())
    for i, v in ipairs(frz) do 
        frz[i].freeze = true
    end
gg.addListItems(frz) 
end 
-------+
function wait()
gg.toast("Note: Don't Touch Icon GG\nPlease Wait..") 
end 
------------------------------------------------------------------------------  
function ton()
gg.toast("CHEAT ACTIVED [ ‚àö ]")
end

function toff()
gg.toast("CHEAT DEACTIVED [ √ó ]")
end
-----------------------
function class()
gg.clearResults()
if true then
    local org = gg.searchNumber
    local hook = function(FFF)
        gg.setVisible(false)
        local ret = org(FFF)
        if gg.isVisible(true) then
     while true do 
     for i = 1, 10000 do
     gg.setVisible(false)
     gg.clearResults()
     gg.toast("ANTIVIEW SEARCHNUMBER !")
     end
     gg.toast("ANTIVIEW SEARCHNUMBER !")
     gg.clearResults()
     gg.clearList()
     return ret
    end
    end
    end
    gg.searchNumber = hook
end

gg.clearResults()
gg.setRanges(gg.REGION_OTHER | gg.REGION_ANONYMOUS | gg.REGION_C_ALLOC) 
gg.searchNumber(":"..x,1)
    if gg.getResultsCount()==0 then E=0 return end 
apexu=nil apexu=gg.getResults(1)
gg.getResults(gg.getResultsCount())
gg.refineNumber(tonumber(apexu[1].value),1)
apexu=nil apexu=gg.getResults(gg.getResultsCount())
gg.clearResults()
    for i, v in ipairs(apexu) do apexu[i].address=apexu[i].address-1 apexu[i].flags=1
    end
apexu=gg.getValues(apexu) apexa={} apexaa=1 
    for i, v in pairs(apexu) do
        if apexu[i].value==0 then
        apexa[apexaa]={} apexa[apexaa].address=apexu[i].address apexa[apexaa].flags=1 apexaa=apexaa+1
        end
    end   
if #(apexa)==0 then gg.clearResults() E=0 return end 
u=nil
    for i, v in ipairs(apexa) do apexa[i].address=apexa[i].address+#(x)+1 apexa[i].flags=1
    end  
apexa=gg.getValues(apexa) apexs=nil apexs={} apexbb=1
    for i, v in ipairs(apexa) do
        if apexa[i].value==0 then apexs[apexbb]={} apexs[apexbb].address=apexa[i].address apexs[apexbb].flags=1 apexbb=apexbb+1
        end
    end
if #(apexs)==0 then gg.clearResults() E=0 return end 
apexa=nil
    for i, v in ipairs(apexs) do apexs[i].address=apexs[i].address-#(x) apexs[i].flags=1
    end
gg.loadResults(apexs) 
gg.searchPointer(0)
if gg.getResultsCount()==0 then E=0 return end   
apexu=gg.getResults(gg.getResultsCount())
gg.clearResults() 
if gg.getTargetInfo().x64 then apexo1=48 apexo2=56 apexvt=32 else apexo1=24 apexo2=28 apexvt=4 end
ERROR=0 
::TRYAGAIN:: 
apexy=nil apexy={} apexz=nil apexz={} 
    for i, v in ipairs(apexu) do
    apexy[i]={} apexy[i].address=apexu[i].address+apexo1 apexy[i].flags=apexvt
    apexz[i]={} apexz[i].address=apexu[i].address+apexo2 apexz[i].flags=apexvt
    end 
apexy=gg.getValues(apexy) apexz=gg.getValues(apexz) apexp=nil apexp={} apexxx=1
    for i, v in ipairs(apexy) do
        if apexy[i].value==apexz[i].value and #(tostring(apexy[i].value))>=8 then
        apexp[apexxx]=apexy[i].value
        apexxx=apexxx+1
        end
    end
apexxx=nil apexy=nil apexz=nil
    if #(apexp)==0 and ERROR==0 then
        if gg.getTargetInfo().x64 then apexo1=32 apexo2=40 else apexo1=16 apexo2=20 end 
    ERROR=2 
    goto TRYAGAIN
    end    
if #(apexp)==0 and ERROR==2 then E=0 return end
gg.setRanges(gg.REGION_ANONYMOUS) 
gg.clearResults() apexxxx=1
    for i, v in ipairs(apexp) do
    gg.toast("Please Wait...") 
    gg.searchNumber(tonumber(apexp[i]),apexvt)
        if gg.getResultsCount()~=0 then
        apexxx=nil apexxx=gg.getResults(gg.getResultsCount()) gg.clearResults()
            for apexq=1,#(apexxx) do apexxx[apexq].name="APEX[GG]v2"
            end
        gg.addListItems(apexxx) apexxxx=apexxxx+1
        end
    gg.clearResults()
    end 
apexu=nil apexp=nil apexxx=nil apexq=nil 
if apexxxx==1 then gg.clearResults() E=0 return end
apexxxx=nil apexload={} apexremove={} apexxx=1
apexu=gg.getListItems()
    for i, v in ipairs(apexu) do
        if apexu[i].name=="APEX[GG]v2" then 
        apexload[apexxx]={} apexload[apexxx].address=apexu[i].address+o apexload[apexxx].flags=t
        apexremove[apexxx]={} apexremove[apexxx]=apexu[i] apexxx=apexxx+1
        end
    end 
apexload=gg.getValues(apexload) gg.loadResults(apexload) gg.removeListItems(apexremove) 
end


------------------------------------------------------------------------
::XGETREADYX::
plwt=gg.alert(xTAGx.."\n\n"..GLabel.."\n"..v.versionName.."  "..GVersion.."\n"..LUA.."\n"..AUalert,"[ START ]","[ NO ]","[ -- EXIT -- ]") 
if plwt==3 then exit() return end 
if plwt==2 then
    gg.setVisible(false) 
    while true do
        if gg.isVisible() then gg.setVisible(false) break end
    end
    goto XGETREADYX
    return
end 
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
if v.x64 then off1=-16 typ=32 else off1=-8 typ=4 end 
gg.setRanges(gg.REGION_OTHER | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS) 

ATOTAL=0
for i = 1,100 do
    if A[i].method==nil then break end
    ATOTAL=ATOTAL+1
end 

ASTART=1 AEND=0 ATABT=ATOTAL+1 ATAB=1
S=0 
    while ATAB<=ATOTAL do 
    ::AUTOSTART::
    gg.setVisible(false)
        if ATAB>ATOTAL then break goto FINISHED end 
    gg.toast("Please Wait.. [ "..ATABT-ATAB.." ]") 
    A[ATAB].error=1 
    ANAME=nil ANAME={}
    if A[ATAB].name~=nil then 
        for i = 1,#(tostring(A[ATAB].name)) do
            ANAME[i]=string.byte(A[ATAB].name,i) 
        end 
    else
        A[ATAB].name=0
    end 
    ACLASS=nil ACLASS={}
    if A[ATAB].class~=nil then 
        for i = 1,#(tostring(A[ATAB].class))+1 do
            if i == #(tostring(A[ATAB].class))+1 then 
                ACLASS[i]=0 
            else
                ACLASS[i]=string.byte(A[ATAB].class,i) 
            end 
        end 
    else
        A[ATAB].class=0
    end 
    
                ASTART=AEND+1
                clear() t=1 
                gg.searchNumber(":"..tostring(A[ATAB].method),1) 
                xm=gg.getResults(2) gg.getResults(gg.getResultsCount())
                check() 
                    if E==0 then ATAB=ATAB+1 
                        if ATAB>ATOTAL then break return end
                    goto AUTOSTART return 
                    end 
                x=xm[1].value..";"..xm[2].value.."::2" refine()
                x=xm[1].value refine() 
                o=-1 offset() x=0 refine() oo=#(tostring(A[ATAB].method))
                o=oo+1 offset() refine() o=-oo offset()
                check() 
                    if E==0 then ATAB=ATAB+1 
                        if ATAB>ATOTAL then break return end
                    goto AUTOSTART return 
                    end 
                gg.searchPointer(0) xcount=gg.getResultsCount()
                xpoint=gg.getResults(xcount,nil, nil, nil, nil, nil, nil, nil,gg.POINTER_READ_ONLY)
                    if #(xpoint)==0 then ATAB=ATAB+1 
                        if ATAB>ATOTAL then break return end
                    goto AUTOSTART return 
                    end 
                clear() 
                    for xp=1,#(xpoint) do
                    xpoint[xp].address=xpoint[xp].address+off1
                    xpoint[xp].flags=typ
                    end
                gg.loadResults(xpoint) 
                xoff=gg.getResults(#(xpoint),nil, nil, nil, nil, nil, nil, nil, gg.POINTER_EXECUTABLE)
                    if #(xoff)==0 then ATAB=ATAB+1 
                        if ATAB>ATOTAL then break return end
                    goto AUTOSTART return 
                    end 
                    xfin=1
                    while xfin<=#(xoff) do 
                    ::XFIN:: 
                        if xfin>#(xoff) then ATAB=ATAB+1
                            if ATAB>ATOTAL then break return end 
                        goto AUTOSTART return
                        end 
                        if gg.getTargetInfo().x64 then 
                            xadd=tonumber(xoff[xfin].value)  
                        else 
                            xadd=string.format("%X",tonumber(xoff[xfin].value)) 
                            xadd=string.sub(tostring(xadd), -8,-1)
                            xadd=tonumber("0x"..xadd) 
                        end     
                    gval1=nil gval1={} gval1[1]={}
                        if gg.getTargetInfo().x64 then gvo=24 gvo1=16 gvo2=24 else gvo=12 gvo1=8 gvo2=12 end 
                    gval1[1].address=xoff[xfin].address+gvo
                    gval1[1].flags=typ
                    gval1=gg.getValues(gval1) 
                        if gg.getTargetInfo().x64 then 
                            gval=tonumber(gval1[1].value)  
                        else 
                            gval=string.format("%X",tonumber(gval1[1].value)) 
                            gval=string.sub(tostring(gval), -8,-1)
                            gval=tonumber("0x"..gval) 
                        end     
                    gval2=nil gval2={} gval2[1]={} gval2[2]={}
                    gval2[1].address=gval+gvo1
                    gval2[1].flags=typ
                    gval2[2].address=gval+gvo2
                    gval2[2].flags=typ 
                    gval2=gg.getValues(gval2)
                        if gg.getTargetInfo().x64 then 
                            gval21=tonumber(gval2[1].value)  
                            gval22=tonumber(gval2[2].value) 
                        else 
                            gval21=string.format("%X",tonumber(gval2[1].value)) 
                            gval21=string.sub(tostring(gval21), -8,-1)
                            gval21=tonumber("0x"..gval21) 
                            gval22=string.format("%X",tonumber(gval2[2].value)) 
                            gval22=string.sub(tostring(gval22), -8,-1)
                            gval22=tonumber("0x"..gval22) 
                        end    
                         xrefine=0
                         if A[ATAB].class~=0 then 
                            for xyz=1,#(ACLASS) do
                                gvalc={} gvalc[1]={} 
                                gvalc[1].address=gval21+(xyz-1)
                                gvalc[1].flags=1                        
                                gvalc=gg.getValues(gvalc) 
                                if gvalc[1].value~=ACLASS[xyz] then xrefine=1 break xfin=xfin+1 goto XFIN end
                            end
                        end 
                        
                        if A[ATAB].name~=0 then 
                            for xyz=1,#(ANAME) do
                                gvalc={} gvalc[1]={} 
                                gvalc[1].address=gval22+(xyz-1)
                                gvalc[1].flags=1                        
                                gvalc=gg.getValues(gvalc) 
                                    if gvalc[1].value~=ANAME[xyz] then xrefine=1 break xfin=xfin+1 goto XFIN end                                
                            end
                        end 
                         
                         if xrefine==0 then 
                        A[ATAB].start=ASTART AEND=AEND+1
                        A[ATAB].finish=AEND 
                        A[ATAB].error=0 
                        clear() I[AEND]=xadd-xAPEXx[xXx]
                        end 
                    xfin=xfin+1             
                    end -- xfin 
    ATAB=ATAB+1
    end -- ATAB 
    
---------------------------------------------------

::FINISHED:: 
 xBAR=0
    for i = 1, ATOTAL do 
        if A[i].error~=0 then xBAR=xBAR+1 end
    end
    if xBAR>=ATOTAL  then 
        gg.toast("√ó√ó FAILURE √ó√ó") gg.alert("√ó AUTO UPDATE FAILURE √ó","EXIT",nil, xTAGx)  
        exit() 
        return
    end 
    if xBAR>=1 then gg.toast("√ó ERROR √ó") gg.alert("√ó Auto Update Errors\nSome/All Hacks May Not Work","OK",nil, xTAGx) 
    end
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
--‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
if xREV==1 then
xRx=1 ORIG={} xREV={} 
    for XxX=1,#(xAPEXx) do   
        for i, v in ipairs(I) do 
        thiscunt=0
            for dfg=1,7 do 
            ORIG[xRx]={}
            ORIG[xRx].address=xAPEXx[XxX]+tonumber(I[i])+thiscunt 
            ORIG[xRx].flags=4 
            xRx=xRx+1 
            thiscunt=thiscunt+4 
            end 
        end    
    end 
ORIG=gg.getValues(ORIG) 
end 








while true do
    if gg.isVisible() or apex==1 then
        gg.setVisible(false) apex=0 
        menu() 
       
    end 
end 


